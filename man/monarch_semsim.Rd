% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/monarch_semsim.R
\name{monarch_semsim}
\alias{monarch_semsim}
\title{Semantic similarity mapping between two graphs}
\usage{
monarch_semsim(
  query_graph,
  target_graph,
  metric = "ancestor_information_content",
  include_reverse = FALSE,
  keep_unmatched = FALSE
)
}
\arguments{
\item{query_graph}{A tbl_kgx graph.}

\item{target_graph}{A tbl_kgx graph.}

\item{metric}{The semantic similarity metric to use. Default is \code{"ancestor_information_content"}. Also available are \code{"jaccard_similarity"} and \code{"phenodigm_score"}.}

\item{include_reverse}{Whether to include the best matches from the target graph to the query graph. Default is \code{FALSE}.}

\item{keep_unmatched_targets}{Whether to keep nodes in the target graph that do not have a match. Default is \code{FALSE}.}
}
\value{
A tbl_kgx graph with \code{"computed:best_matches"} edges between the nodes of the two input graphs.
}
\description{
This function calls the Monarch-hosted semantic similarity API to compare two
graphs, via the same endpoints as the Monarch Phenotype Explorer:
https://monarchinitiative.org/explore#phenotype-explorer.
}
\details{
The API returns the best matches between the nodes of the two graphs, based on
a specified knowledge-graph-boased metric: the default is \code{"ancestor_information_content"},
also available are \code{"jaccard_similarity"} and \code{"phenodigm_score"}. The result is
returned as a graph, with \code{"computed:best_matches"} edges between the nodes of the two input graphs.

By default, the function only returns the best matches from the first graph to the second graph, and
removes any nodes that do not have a match. If \code{include_reverse = TRUE}, the function also returns
the best matches from the second graph to the first graph.

The engine attached to the return graph is that of the query.
}
\examples{
\dontshow{if (monarch_engine_check(service = "semsim")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}

g1 <- monarch_engine() |>
  fetch_nodes(query_ids = "MONDO:0007947") |>
  expand(result_categories = "biolink:PhenotypicFeature")

g2 <- monarch_engine() |>
  fetch_nodes(query_ids = "MONDO:0007522") |>
  expand(result_categories = "biolink:PhenotypicFeature")

sim <- monarch_semsim(g1, g2)
print(sim)

# also inclue the unmatched targets
sim <- monarch_semsim(g1, g2, keep_unmatched = TRUE)
print(sim)

# inclue reverse matches
sim <- monarch_semsim(g1, g2, include_reverse = TRUE)
print(sim)
\dontshow{\}) # examplesIf}
}
